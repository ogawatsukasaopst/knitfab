package cert

import (
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"math/big"
	"net"
	"sync"
	"time"
)

type Cert struct {
	Certificate []byte
	PrivateKey  *rsa.PrivateKey
	PEM         []byte
	PEMKey      []byte
}

func (c *Cert) TLSCert() (*tls.Certificate, error) {
	cert, err := tls.X509KeyPair(c.PEM, c.PEMKey)
	return &cert, err
}

type CA interface {
	// Get Public Key of this CA
	PublicKey() *rsa.PublicKey

	// Generate a new Certificate
	Certificate(opts ...CertOption) (*Cert, error)

	// CA Certificate in PEM expression
	PEM() []byte
}

type ca struct {
	cacert  *x509.Certificate
	pkey    *rsa.PrivateKey
	certpem []byte
	serial  *big.Int
	mux     sync.Mutex
}

func (c *ca) PublicKey() *rsa.PublicKey {
	return &c.pkey.PublicKey
}

func (c *ca) PEM() []byte {
	return c.certpem
}

// Create on-memory CA.
//
// this ca has defaults of...
// - NotAfter: 365 days
// - CommonName: "test CA"
//
// It's key is generated by RSA with 2048 bits key.
//
// If you need customizations, pass `CertOption`.
func NewCA(options ...CertOption) (CA, error) {
	k, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return nil, err
	}

	serial := big.NewInt(1)
	tpl := &x509.Certificate{
		SerialNumber: serial,
		Subject: pkix.Name{
			CommonName: "test CA",
		},
		NotBefore: time.Now(),
		NotAfter:  time.Now().Add(365 * 24 * time.Hour),
		IsCA:      true,
		KeyUsage:  x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
		ExtKeyUsage: []x509.ExtKeyUsage{
			x509.ExtKeyUsageClientAuth,
			x509.ExtKeyUsageServerAuth,
		},
		BasicConstraintsValid: true,
	}
	for _, o := range options {
		tpl, err = o(tpl)
		if err != nil {
			return nil, err
		}
	}

	// self-signed CA!
	raw, err := x509.CreateCertificate(rand.Reader, tpl, tpl, k.Public(), k)

	if err != nil {
		return nil, err
	}

	buf := bytes.NewBuffer(nil)
	if err := pem.Encode(
		buf,
		&pem.Block{
			Type:  "CERTIFICATE",
			Bytes: raw,
		},
	); err != nil {
		return nil, err
	}

	return &ca{
		cacert:  tpl,
		pkey:    k,
		certpem: buf.Bytes(),
		serial:  serial,
	}, nil
}

func (c *ca) Certificate(opts ...CertOption) (*Cert, error) {
	c.mux.Lock()
	defer c.mux.Unlock()

	k, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return nil, err
	}

	c.serial = c.serial.Add(c.serial, big.NewInt(1))

	tpl := &x509.Certificate{
		SerialNumber: c.serial,
		Subject: pkix.Name{
			CommonName: "test.local",
		},
		NotBefore: time.Now(),
		NotAfter:  time.Now().Add(365 * 24 * time.Hour),
		ExtKeyUsage: []x509.ExtKeyUsage{
			// x509.ExtKeyUsageClientAuth,
			x509.ExtKeyUsageServerAuth,
		},
		KeyUsage: x509.KeyUsageDigitalSignature,
	}

	for _, o := range opts {
		tpl, err = o(tpl)
		if err != nil {
			return nil, err
		}
	}

	cert, err := x509.CreateCertificate(rand.Reader, tpl, c.cacert, k.Public(), c.pkey)
	if err != nil {
		return nil, err
	}

	pembuf := bytes.NewBuffer(nil)
	if err := pem.Encode(pembuf, &pem.Block{
		Type:  "CERTIFICATE",
		Bytes: cert,
	}); err != nil {
		return nil, err
	}

	pkeybuf := bytes.NewBuffer(nil)
	if err := pem.Encode(pkeybuf, &pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: x509.MarshalPKCS1PrivateKey(k),
	}); err != nil {
		return nil, err
	}

	bundle := &Cert{
		Certificate: cert,
		PrivateKey:  k,
		PEM:         pembuf.Bytes(),
		PEMKey:      pkeybuf.Bytes(),
	}

	return bundle, err
}

type CertOption func(*x509.Certificate) (*x509.Certificate, error)

func WithIP(ipaddr net.IP) CertOption {
	return func(c *x509.Certificate) (*x509.Certificate, error) {
		if c.IPAddresses == nil {
			c.IPAddresses = []net.IP{}
		}
		c.IPAddresses = append(c.IPAddresses, ipaddr)
		return c, nil
	}
}

func NotAfter(t time.Time) CertOption {
	return func(c *x509.Certificate) (*x509.Certificate, error) {
		c.NotAfter = t
		return c, nil
	}
}

func DNSName(cn string) CertOption {
	return func(c *x509.Certificate) (*x509.Certificate, error) {
		c.DNSNames = append([]string{cn}, c.DNSNames...)
		return c, nil
	}
}

func IP(ip net.IP) CertOption {
	return func(c *x509.Certificate) (*x509.Certificate, error) {
		c.IPAddresses = append([]net.IP{ip}, c.IPAddresses...)
		return c, nil
	}
}
